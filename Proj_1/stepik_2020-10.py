# =================================================================================================
#                            2.4 Строки и символы
# =================================================================================================

# ========================== 2.4.1 ================================================================
'''GC-состав является важной характеристикой геномных последовательностей и определяется как процентное соотношение
суммы всех гуанинов и цитозинов к общему числу нуклеиновых оснований в геномной последовательности.

Напишите программу, которая вычисляет процентное содержание символов G (гуанин) и C (цитозин) в введенной строке
(программа не должна зависеть от регистра вводимых символов).

Например, в строке "acggtgttat" процентное содержание символов G и C равно (4/10)⋅100=40.0, где 4 - это количество
символов G и C,  а 10 - это длина строки.'''

def f241():
    s=input()
    l=len(s)
    s=s.upper()
    g=s.count('G')
    c=s.count('C')
    print((g+c)*100/l)
    return

# ========================== 2.4.2 ================================================================
'''Узнав, что ДНК не является случайной строкой, только что поступившие в Институт биоинформатики студенты группы
информатиков предложили использовать алгоритм сжатия, который сжимает повторяющиеся символы в строке.

Кодирование осуществляется следующим образом:
s = 'aaaabbсaa' преобразуется в 'a4b2с1a2', то есть группы одинаковых символов исходной строки заменяются на этот
символ и количество его повторений в этой позиции строки.

Напишите программу, которая считывает строку, кодирует её предложенным алгоритмом и выводит закодированную
последовательность на стандартный вывод. Кодирование должно учитывать регистр символов.'''

def f242():
    s=input()
    n=1
    s1,s2, ss = '','',''
    for i in range(len(s)-1):
        s1=s[i]
        s2=s[i+1]
        if s1==s2:
            n += 1
        else:
            ss = ss+s1+str(n)
            n = 1
    if len(s) == 1:
        ss = s+str(n)
    else:
        ss = ss+s2+str(n)
    print (ss)
    return


# =================================================================================================
#                            2.6.1
# =================================================================================================

''' Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор, пока сумма введённых чисел
не будет равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел.

Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0, после этого считывание продолжать не нужно.

В примере мы считываем числа 1, -3, 5, -6, -10, 13; в этот момент замечаем, что сумма этих чисел равна нулю
и выводим сумму их квадратов, не обращая внимания на то, что остались ещё не прочитанные значения.'''


def f261():
    a = [int(input())]
    i = 0
    s = a[i]
    while s != 0:
        i += 1
        a.append(int(input()))
        s += a[i]
    p = 0
    l = len(a)
    for i in range(l):
        p += a[i] ** 2
    print(p)
    return 0


# =================================================================================================
#                            2.6.2
# =================================================================================================

''' Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число 
повторяется столько раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов 
последовательности должна отобразить программа. На выходе ожидается последовательность чисел, записанных через пробел 
в одну строку.

Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.
'''


def f262():
    n = int(input())
    i, j = 0, 0
    while i < n:
        j += 1
        x, k = j, 1
        while x >= k:
            k += 1
            i += 1
            print(x, end=' ')
            if i == n:
                break
    return 0


# =================================================================================================
#                            2.6.3
# =================================================================================================

''' Напишите программу, которая считывает список чисел lst из первой строки и число x из второй строки, 
которая выводит все позиции, на которых встречается число x в переданном списке lst.

Позиции нумеруются с нуля, если число x не встречается в списке, вывести строку "Отсутствует" (без кавычек, 
с большой буквы).

Позиции должны быть выведены в одну строку, по возрастанию абсолютного значения.
'''


def f263():
    st = [int(i) for i in input().split()]
    x = int(input())
    k, e = 0, 0
    for i in st:
        if i == x:
            print(k, end=' ')
            e += 1
        k += 1
    if e == 0:
        print('Отсутствует')
    return 0


# =================================================================================================
#                            2.6.4
# =================================================================================================

''' Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк, 
заканчивающихся строкой, содержащей только строку "end" (без кавычек)

Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов 
первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится 
с противоположной стороны матрицы.

В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.
'''


def f264():
    j = 0
    a = []
    while j >= 0:
        st = [i for i in input().split()]
        if st[0] == 'end':
            j = -1
        else:
            st = [int(i) for i in st]
            a.append(st)
            j += 1
    n = len(a)
    k = len(a[0])
    b = []
    for i in range(n):
        c = []
        for j in range(k):
            x1 = i - 1
            x2 = i + 1
            y1 = j - 1
            y2 = j + 1
            if i == 0:
                x1 = n - 1
            if i == n - 1:
                x2 = 0
            if j == 0:
                y1 = k - 1
            if j == k - 1:
                y2 = 0
            c += [a[x1][j] + a[x2][j] + a[i][y1] + a[i][y2]]
            print(c[j], end=' ')
        b.append(c)
        print()
    return 0


# =================================================================================================
#                            2.6.5
# =================================================================================================

''' Выведите таблицу размером n×n, заполненную числами от 1 до n^2 по спирали, выходящей из левого верхнего угла 
и закрученной по часовой стрелке, как показано в примере (здесь n=5)

Sample Input:
5

Sample Output:
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
'''


def gonext(a, b):
    b += 1
    if b == len(a):
        b = 0
    return b


def f265():
    n = int(input('Введите размер таблицы n*n : '))
    #    n = int(input())
    ar = [[0] * n for _ in range(n)]
    #    print(ar)
    cl = n ** 2
    c, i, j = 1, 0, 0
    di = ['right', 'down', 'left', 'up']
    idi = 0
    ar[i][j] = c
    while c < cl:
        st = 0
        while st == 0:
            if di[idi] == 'right':
                if j == n - 1:
                    idi = gonext(di, idi)
                else:
                    j += 1
                    if ar[i][j] != 0:
                        idi = gonext(di, idi)
                        j -= 1
                    else:
                        st = 1
            if di[idi] == 'left':
                if j == 0:
                    idi = gonext(di, idi)
                else:
                    j -= 1
                    if ar[i][j] != 0:
                        idi = gonext(di, idi)
                        j += 1
                    else:
                        st = 1
            if di[idi] == 'down':
                if i == n - 1:
                    idi = gonext(di, idi)
                else:
                    i += 1
                    if ar[i][j] != 0:
                        idi = gonext(di, idi)
                        i -= 1
                    else:
                        st = 1
            if di[idi] == 'up':
                if i == 0:
                    idi = gonext(di, idi)
                else:
                    i -= 1
                    if ar[i][j] != 0:
                        idi = gonext(di, idi)
                        i += 1
                    else:
                        st = 1
        c += 1
        ar[i][j] = c
    for i in range(n):
        for j in range(n):
            if ar[i][j] < 10:
                print('', ar[i][j], end=' ')
            else:
                print(ar[i][j], end=' ')
        print()

    return 0


# ===== поворот матрицы против часовой стрелки ======
'''
for j in range(n-1, -1, -1):
    for i in ar:
        print(i[j], end=" ")
    print()
'''

# =================================================================================================
#                            3.1.1
# =================================================================================================
''' Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:
f(x)={ 1−(x+2)^2,   при x≤−2 
        −x/2,       при −2<x≤2 
        (x−2)^2+1,  при 2<x 
Требуется реализовать только функцию, решение не должно осуществлять операций ввода-вывода.
'''


def fx(x):
    if x <= -2:
        return 1 - (x + 2) ** 2
    elif x <= 2:
        return -x / 2
    else:
        return (x - 2) ** 2 + 1


def f311():
    x = float(input())
    print(fx(x))


# =================================================================================================
#                            3.1.2
# =================================================================================================
''' Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него 
все нечётные значения, а чётные нацело делит на два. 
Функция не должна ничего возвращать, требуется только изменение переданного списка
'''


def modify_list(l):
    ll, i = len(l), 0
    while i < ll:
        if l[i] % 2 == 0:
            l[i] = l[i] // 2
            i += 1
        else:
            del l[i]
            ll -= 1
    return


def f312():
    lst = [int(i) for i in input().split()]
    #    print(lst)
    print(modify_list(lst))
    print(lst)
    modify_list(lst)
    print(lst)


# =================================================================================================
#                            3.2.1 Множества (sets)
# =================================================================================================
def f3201():
    basket = set()
    box = {'apple', 'banana'}
    print(box)
    print(basket)
    basket.add('orange')
    print(len(basket))
    print(basket)
    for i in box:
        basket.add(i)
    print(len(basket))
    print(basket)
    st = input()
    if st in basket:
        basket.remove(st)
    print(basket)
    return


def f3202():
    d1 = {}
    d2 = dict()
    d3 = {1: 'Ann', 2: 'Bob', 3: 'Clair'}
    d1['a'] = 101
    print(d1['a'])
    print(d2)
    d3[4] = 'Dick'
    print(d3)
    print(d3.get(1))
    del d3[3]
    print(d3)
    for key in d3:
        print(key, end=' ')
    print()
    for key in d3.keys():
        print(key, end=' ')
    print()
    for val in d3.values():
        print(val, end=' ')
    print()
    for key, val in d3.items():
        print(key, val, end=' ')
    print()
    d3[3] = ['Cat', 'Chack']
    for key, val in d3.items():
        print(key, val, end=' ')
    return


# ========================================== 3.2.1 ===========================================
''' Напишите функцию update_dictionary(d, key, value), которая принимает на вход словарь d 
и два числа: key и value.

Если ключ key есть в словаре d, то добавьте значение value в список, который хранится по этому ключу.
Если ключа key нет в словаре, то нужно добавить значение в список по ключу 2∗key.
Если и ключа 2∗key нет, то нужно добавить ключ 2∗key в словарь и сопоставить ему список из 
переданного элемента [value].

Требуется реализовать только эту функцию, кода вне неё не должно быть.
Функция не должна вызывать внутри себя функции input и print.'''


def update_dictionary0(d, key, value):
    k = key
    if k in d.keys():
        lst = d[k]
        lst.append(value)
    #        print(d[k])
    else:
        if k * 2 in d.keys():
            lst = d[k * 2]
            lst.append(value)
        #           print(d[k*2])
        else:
            d[k * 2] = [value]
    return


def update_dictionary1(d, key, value):
    if key in d:
        d[key] += [value]
    elif 2 * key in d:
        d[2 * key] += [value]
    else:
        d[2 * key] = [value]
    return


'''get(key) по умолчанию возвращает None если ключа нет в списке. 
Но вы можете изменить это значение передав его в функцию через запятую после значения ключа 
get(key, value) (по аналогии с функцией range()). В данном случае он меняет None на пустой список []. 
В случае, если такого ключа не будет в словаре, то функция get вернет не None, а вернет пустой список. 
Следовательно, у нас появится ключ key, которому будет соответствовать значение [] (т.е пустой список).'''


def update_dictionary(d, key, value):
    key += key * (key not in d)
    d[key] = d.get(key, []) + [value]
    return


def f321():
    d = {}
    print(update_dictionary(d, 1, -1))  # None
    print(d)  # {2: [-1]}
    update_dictionary(d, 2, -2)
    print(d)  # {2: [-1, -2]}
    update_dictionary(d, 1, -3)
    print(d)


# ========================================== 3.2.2 ===========================================
'''Когда Антон прочитал «Войну и мир», ему стало интересно, сколько слов и в каком количестве 
используется в этой книге.

Помогите Антону написать упрощённую версию такой программы, которая сможет подсчитать слова, 
разделённые пробелом и вывести получившуюся статистику.

Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального 
слова в этой строке число его повторений (без учёта регистра) в формате "слово количество" 
(см. пример вывода).
Порядок вывода слов может быть произвольным, каждое уникальное слово должно выводиться только один раз.'''

    # dic = {key:value for key in source}

def f322():
    str = input().lower().split()
    dic = {}
    for i in str:
        if i in dic:
            dic[i] += 1
        else:
            dic[i] = 1
    for key, val in dic.items():
        print(key,val)
    return

def f3221():
    str = input().lower().split()
    ar = []
    for i in str:
        if i not in ar:
            ar.append(i)
    for i in ar:
        print(i,str.count(i))
    return

def f3222():
    str = input().lower().split()
    for i in set(str):
        print(i,str.count(i))
    # print(set(str))
    return

'''Решение компактнее, чем через словарь, но если посмотреть на время выполнения, 
то уже на данных от 20-25 слов суммарно получается медленее выполнение. 
Из-за того, что вот так count считать всё время по большому массиву - очень невыгодно'''

def f3223():
    str = input().lower().split()
    [print(i,str.count(i)) for i in set(str)]
    return

def f3224():
    x = input().lower().split()
    a = {i:x.count(i) for i in x}
    {print(i,j) for i,j in a.items()}
    return

def f3225():
    x = input().lower().split()
    # t1 = timeit.default_timer()
    a = {i:0 for i in x}
    for i in x:
        a[i] += 1
    [print(i,j) for i,j in a.items()]
    # print(timeit.default_timer()-t1)
    return

# ========================================== 3.2.3 ===========================================
'''Напишите программу, которая считывает строку с числом n, которое задаёт количество чисел, которые нужно считать. 
Далее считывает n строк с числами xi, по одному числу в каждой строке. Итого будет n+1 строк.

При считывании числа xi программа должна на отдельной строке вывести значение f(xi). 
Функция f(x) уже реализована и доступна для вызова. 

Функция вычисляется достаточно долго и зависит только от переданного аргумента x. 
Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.'''

def f(x):
    return x**16

def f323():
    n = int(input())
    dic = {}
    for _ in range(n):
        a = int(input())
        if a not in dic.keys():
            dic[a] = f(a)
        print (dic[a])
    print(dic)
    return

# Генераторы - это вещь!
def f3231():
    a=[int(input()) for i in range(int(input()))]
    b={x:f(x) for x in set(a)}
    for i in a:
        print(b[i])
    print(b)
    return

def f3232():
    a = [int(input()) for i in range(int(input()))]
    b = {x:f(x) for x in set(a)}
    print (*[b[i] for i in a], sep='\n')

# =================================================================================================
#                            3.4 Файловый ввод/вывод
# =================================================================================================

def f340 ():
    inf = open('file.txt','r')
    s1 = inf.readline()
    s2 = inf.readline()
    inf.close()

    # альтернативный, предпочтительный способ доступа к файлу
    with open('text.txt') as inf:
        s1 = inf.readline()
        s2 = inf.readline()
    # здесь файл уже закрыт

    # функция strip убирает служебные символы с обоих концов строки
    s = inf.readline().strip()

    # функция сборки пути к файлу независимо от типа ОС
    import os
    os.path.join('.','dirname','filename.txt')  # результат для linux: ./dirname/filename.txt

    # построчное чтение файла
    with open('input.txt') as inf:
        for line in inf:
            line = line.strip()
            print(line)

    # запись в файл
    ouf = open('file.txt','w')
    ouf.write('Some text\n')
    ouf.write(str(255))
    ouf.close()

    with open('text.txt','w') as ouf:
        ouf.write('Some text\n')
        ouf.write(str(255))
    # здесь файл уже закрыт

# ========================================== 3.4.1 ===========================================
'''На прошлой неделе мы сжимали строки, используя кодирование повторов. Теперь нашей задачей будет восстановление 
исходной строки обратно.
Напишите программу, которая считывает из файла строку, соответствующую тексту, сжатому с помощью кодирования повторов, 
и производит обратную операцию, получая исходный текст.
Запишите полученный текст в файл и прикрепите его, как ответ на это задание.
В исходном тексте не встречаются цифры, так что код однозначно интерпретируем.

Примечание. Это первое задание типа Dataset Quiz. В таких заданиях после нажатия "Start Quiz" у вас появляется ссылка 
"download your dataset". Используйте эту ссылку для того, чтобы загрузить файл со входными данными к себе на компьютер. 
Запустите вашу программу, используя этот файл в качестве входных данных. Выходной файл, который при этом у вас 
получится, надо отправить в качестве ответа на эту задачу. '''

def f341decomp(str):
    i,line = 0,''
    while i<len(str):
        # print(str[i])
        if 'A'<=str[i]<='z':
            a,b = str[i],''
            i += 1
            while i<len(str):
                if '0'<=str[i]<='9':
                    b += str[i]
                    i += 1
                else:
                    break
            line += a*int(b)
        else:
            i += 1
    return line

def f341decomp1(str):
    #strin = open("dataset_3363_2.txt", 'r').readline().strip()  # считываем сразу в строку, потому что она тут одна
    lst = []  # создаем пустой список, в который будем пихать буквы с циферками по типу [a10, b2...]
    line = ''
    for i in range(len(str)):
        if str[i].isalpha():  # проверяем каждый символ в строке на букву
            lst.append(str[i])  # записываем в список буковку
        else:
            lst[-1] += str[i] # бомбим рядом с буквой ее циферки
    for a in lst:
        line += a[0]*int(a[1:])
    # for sym in lst:
        # print(sym[0] * int(sym[1:]), end='') # печатаем буковку (нулевой символ в каждом элементе списка) по
        # количеству ее циферок (остальные символы, преобразованные к числу в соответствующем элементе списка);
        # можно заменить на вывод в файл
    return line

def f341():
    # file reading
    fname = input('File name: ')
    with open(fname,'r') as inf:
        text = [line.strip() for line in inf]
    print(text)

    # decompressing
    outtext = [f341decomp1(line) for line in text]
    print(outtext)

    # file writing
    fname = 'out-'+fname
    with open(fname,'w') as ouf:
        for line in outtext:
            ouf.write(line+'\n')

    return

    # S.isdigit() - Состоит ли (под)строка из цифр
    # S.isalpha() - Состоит ли строка из букв
''' В общем случае, для Windows, если файл находится в произвольной папке, то функция open выглядит так: 
    open ("C:\\Users\\Vanya\\file.txt")'''
''' Для работы с файлами можно воспользоваться такой конструкцией:
    with open ('in.txt') as file_in, open("out.txt", 'w') as file_out:
        for line in file_in:
          ...
        file_out.write(  expanded_text  )'''

def f3411():
    with open('dataset_3363_2.txt', 'r') as f:
        s = f.readline().strip()
        i = 0
        while i < len(s):
            j = i + 1
            while j < len(s) and s[j].isdigit():
                j += 1
            print(s[i] * int(s[i+1:j]), end='')
            i = j
    return

def f3412():
    s, d = input(), []
    for i in s:
        if not i.isdigit(): d.append(i)
        else: d[-1] += i
    print(*[i[0]*int(i[1:]) for i in d], sep='')
    return

def f3413():
    m, s, n = '', '', 0
    with open('dataset_3363_2.txt', 'r+') as f:     # открываем файл в режиме чтение и запись
        for i in f.readline():                      # читаем строку и перебираем
            if '0' <= i <= '9':                     # если число
                n += i                              # соединяем числа в строку
                continue
            m += s * int(n)                         # преобразуем число в соответствующее количество символов
            s, n = i, ''
        f.seek(0)                                   # перемещаем указатель в начало файла для перезаписи
        f.write(m)                                  # записываем преобразованную строку в файл
    return

''' import re    # библиотека с регулярными выражениями, рекомендую прочитать статью 
                                  #https://tproger.ru/translations/regular-expression-python/'''

def f3414():
    code = open('dataset_3363_2.txt', 'r').readline()
    result = ''
    alpha = ''
    digit = 0
    for i in code:
        if i.isalpha():
            result += alpha * digit
            alpha = i
            digit = 0
        if i.isdigit():
            digit = int(str(digit) + i)
    result += alpha * digit
    print(result)
    return

# ========================================== 3.4.2 ===========================================
'''Недавно мы считали для каждого слова количество его вхождений в строку. Но на все слова может быть не так интересно 
смотреть, как, например, на наиболее часто используемые.
Напишите программу, которая считывает текст из файла (в файле может быть больше одной строки) и выводит самое частое 
слово в этом тексте и через пробел то, сколько раз оно встретилось. Если таких слов несколько, вывести 
лексикографически первое (можно использовать оператор < для строк).

В качестве ответа укажите вывод программы, а не саму программу.
Слова, написанные в разных регистрах, считаются одинаковыми.'''

def f342():                             # Плюсы: очень быстро (библию обработал за 0,55 сек)
    fname = input('File name: ')
    t1 = timeit.default_timer()
    wset = dict()
    with open(fname,'r') as inf:
        text = [str.strip() for str in inf]
    # print(text)
    for line in text:
        if line > '':
            for i in line.split():
                wset[i.lower()] = wset.get(i.lower(),0)+1
    # print(wset)
    wrd,wcnt = '',0
    for i in wset.keys():
        if wset[i] > wcnt:
            wrd,wcnt = i,wset[i]
        elif wset[i] == wcnt and i < wrd:
            wrd,wcnt = i,wset[i]
    print(wrd,wcnt)
    print(timeit.default_timer()-t1)
    return

def f3421():                            # print all words, that are repeated in text
    fname = input('File name: ')
    wset = dict()
    with open(fname,'r') as inf:
        text = [str.strip() for str in inf]
    print(text)
    for line in text:
        if line > '':
            print(line.split())     # del after debugging
            for i in line.split():
                wset[i] = wset.get(i,0)+1
    print(wset)
    for key,val in wset.items():
        if val > 1:
            print(key,' ',val)
    return

def f3422():
    with open('text.txt') as f:
        words = f.read().lower().split()
    maxin = 0
    for word in set(words):
        word_in_words = words.count(word)
        if word_in_words > maxin:
            maxin = word_in_words
            popular_word = word
        elif word_in_words == maxin and word < popular_word:
            popular_word = word
    print(popular_word, maxin)
    return

def f3423():                                # Плюс: кратко. Минусы: Работает долго, нет лексикографической сортировки
    fname = input('File name: ')
    with open(fname) as f:
        text = f.read().lower().split()
    popular_word = max(set(text), key=text.count)   # см. комментарий ниже
    # popular_word = max(sorted(set(text)), key=text.count)     # лексикографическая сортировка
    print(popular_word, text.count(popular_word))
    return
'''это именованный параметр функции,который отвечает за критерий сравнения для поиска максимального значения. 
    В данном случае у нас есть множество уникальных слов ,которые содержатся в  файле(это наша коллекция(set(text) 
    к которой применяется функция max ) и мы хотим вернуть самое популярное ,которое чаще всего будет встречаться 
    в тексте. Благодаря ключевому слово key =  мы можем передать любую функцию/метод ,в данном случае передаем count, 
    отвечающий за подсчет количества вхождений данного слова в тексте, которая/ый будет применяться к каждому элементу 
    коллекции.  Вот пример, где сначала мы ведем поиск с критерием по умолчанию (лексикографически), а затем находим 
    максимум по ключевому слову int:
    lis = ['1','100','111','2']
    print(max(lis))                         #2
    print(max(lis,key = lambda x: int(x)))  #111
    print(max(lis,key = int))               #111 '''

''' @Егор_Юлдашев, Обрабатывает войну и мир всего за 25 минут. Респект.
    ...
    max берет элемент из set(text) и считает для него count, потом повторяет для другого элемента? Т.е. сложность n^2?
    ...
    @Игорь_Сокованов, в этом и проблема, что суперкраткие решения могут быть 
    1) не читаемыми вообще 
    2) жрать память или процессор (время).
    У меня код на словаре и без сортировок Войну и Мир (477к слов) смол за 1.4 секунды.'''


def f3424():                                    # Плюсы: экономично, кратко, быстро (библию обработал за 0,87 сек)
    t1 = timeit.default_timer()
    s, d, m, w = str(), dict(), 0, str()
    with open("bible.txt", "r") as f:
        s = f.read().lower().strip().split()
    s.sort()
    for word in s:
        if word in d:
            d[word] += 1
        else:
            d[word] = 1
    for word in d:
        if d[word] > m:
            m = d[word]
            w = word
    print(w,m)
    print(timeit.default_timer()-t1)

    ''' Герман Мальцев
    К моему большому удивлению, работает быстро. Пробовал библию прогнать - заняло около секунды'''

    from collections import Counter

def f3425():
    with open('Bible.txt', 'r') as file:
        words = [i.lower() for i in file.read().split()]
    most_common = Counter(words).most_common(1)[0]
    print(*most_common)
    return

'''Виктор Голованенко
    Моё решение обрабатывает всю Библию за 1 секунду
    
    метод most_common класса Counter возвращает отсортированный по убыванию список значений. 
    Лексиграфическое сравнение происходит при сортировке.
    
    Liudmila Ageeva
    тут многие пишут про книги. Но при этом не проводят дополнительную обработку данных для удаления знаков препинания. 
    А значит те слова, после которых, например, была запятая или точка, будут выделены в отдельные группы и потеряются 
    при подсчете.

    @Liudmila_Ageeva, вы абсолютно правы. Чтобы это исключить, нужно вызвать метод строки replace, вот так:
    
    with open('Bible.txt', 'r') as file:
        words = [i.lower() for i in file.read().replace(';', '').replace(',', '').replace(':', '').split()]    
    most_common = Counter(words).most_common(1)[0]
    print(*most_common)
    '''

# ========================================== 3.4.3 ===========================================
'''Имеется файл с данными по успеваемости абитуриентов. Он представляет из себя набор строк, где в каждой строке 
записана следующая информация:
Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку
Поля внутри строки разделены точкой с запятой, оценки — целые числа.
Напишите программу, которая считывает исходный файл с подобной структурой и для каждого абитуриента записывает его 
среднюю оценку по трём предметам на отдельной строке, соответствующей этому абитуриенту, в файл с ответом.
Также вычислите средние баллы по математике, физике и русскому языку по всем абитуриентам и добавьте полученные 
значения, разделённые пробелом, последней строкой в файл с ответом.
В качестве ответа на задание прикрепите полученный файл со средними оценками по каждому ученику и одной строкой 
со средними оценками по трём предметам.
Примечание. Для разбиения строки на части по символу ';' можно использовать метод split'''

def f343():
    fname = input('File name: ')
    with open(fname,'r') as f:
        table = [l.strip() for l in f]
    foname = 'out-'+fname
    avmath,avphis,avruss,i = 0.0,0.0,0.0,0
    # print(table)
    with open(foname,'w') as f:
        for line in table:
            lvar = line.split(';')
            # print(line)
            # print(lvar)
            mmath = int(lvar[1])
            mphis = int(lvar[2])
            mruss = int(lvar[3])
            avstr = str((mmath+mphis+mruss)/3)+'\n'
            f.writelines(avstr)
            avmath += mmath
            avphis += mphis
            avruss += mruss
            i += 1
        avmath /= i
        avphis /= i
        avruss /= i
        avstr = str(avmath)+' '+str(avphis)+' '+str(avruss)
        f.writelines(avstr)
    return

# =================================================================================================
#                            3.5 Модули
# =================================================================================================

# ========================================== 3.5.1 ===========================================
'''Напишите программу, которая подключает модуль math и, используя значение числа π из этого модуля, находит 
для переданного ей на стандартный ввод радиуса круга периметр этого круга и выводит его на стандартный вывод.'''

def f351():
    r = float(input())
    print(math.pi*r*2)
    return

# ========================================== 3.5.2 ===========================================
'''Напишите программу, которая запускается из консоли и печатает значения всех переданных аргументов на экран 
(имя скрипта выводить не нужно). Не изменяйте порядок аргументов при выводе.
Для доступа к аргументам командной строки программы подключите модуль sys и используйте переменную argv из этого модуля.'''

def f352():
    lt = sys.argv
    st = ''
    for i in range(1,len(lt)):
        st += lt[i]+' '
    print (st)
    return


# =================================================================================================
#                            3.6 Установка дополнительных модулей
# =================================================================================================

# ========================================== 3.6.1 ===========================================
''' Скачайте файл. В нём указан адрес другого файла, который нужно скачать с использованием модуля requests 
и посчитать число строк в нём.
Используйте функцию get для получения файла (имеет смысл вызвать метод strip к передаваемому параметру, чтобы убрать 
пробельные символы по краям).
После получения файла вы можете проверить результат, обратившись к полю text. Если результат работы скрипта 
не принимается, проверьте поле url на правильность. Для подсчёта количества строк разбейте текст с помощью метода 
splitlines.'''

def f361():
    fname = 'dataset_3378_2.txt'
    with open(fname,'r') as f:
        url = f.readline().strip()
    print(url)
    getf = requests.get(url)
    txt = getf.text.splitlines()
    print(getf.text)
    print(txt)
    print(len(txt))
    fname = 'out-'+fname
    with open(fname,'w') as f:
        f.write(getf.text)
    return

# ========================================== 3.6.2 ===========================================
''' Имеется набор файлов, каждый из которых, кроме последнего, содержит имя следующего файла.
Первое слово в тексте последнего файла: "We".
Скачайте предложенный файл. В нём содержится ссылка на первый файл из этого набора.
Все файлы располагаются в каталоге по адресу:
https://stepic.org/media/attachments/course67/3.6.3/
Загрузите содержимое последнего файла из набора, как ответ на это задание.'''

def f362():
    fname = 'dataset_3378_3.txt'
    with open(fname,'r') as f:
        url = f.readline().strip()
    plist = url.split('/')
    rm = plist[-1]
    plist.remove(rm)
    print (plist)
    path = ''
    for i in plist:
        path += i + '/'
    print(path)
    cnt = 0
    print(url)
    while cnt<1000:
        cnt += 1
        getf = requests.get(url)
        txt = getf.text.split()
        # print(txt)
        if txt[0] == 'We':
            print(getf.text)
            print(cnt)
            break
        else:
            url = path+getf.text
        print(url)
    return

# =================================================================================================
#                            3.7 Задачи по материалам недели
# =================================================================================================

# ========================================== 3.7.1 ===========================================
'''Напишите программу, которая принимает на стандартный вход список игр футбольных команд с результатом матча 
и выводит на стандартный вывод сводную таблицу результатов всех матчей.
За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.
Формат ввода следующий:
В первой строке указано целое число n — количество завершенных игр.
После этого идет n строк, в которых записаны результаты игры в следующем формате:
Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой
Вывод программы необходимо оформить следующим образом:
Команда:Всего_игр Побед Ничьих Поражений Всего_очков
Конкретный пример ввода-вывода приведён ниже.
Порядок вывода команд произвольный.'''
'''Спартак;9;Зенит;10
Локомотив;12;Зенит;3
Спартак;8;Локомотив;15'''

def f371():
    n = int(input())
    r = [input().split(';') for _ in range(n)]
    #print(r)
    d = dict()
    for i in range(n):
        t1 = r[i][0]
        sc1 = int(r[i][1])
        t2 = r[i][2]
        sc2 = int(r[i][3])
        d[t1] = d.get(t1,[0,0,0,0,0])
        d[t2] = d.get(t2,[0,0,0,0,0])
        a1 = d[t1]
        a1[0] += 1
        # a2 = d.get(t2,[0,0,0,0,0])
        a2 = d[t2]
        a2[0] += 1
        # d[t1][0] += 1
        # d[t1][0] = d.get(t1,[0,0,0,0,0])[0] + 1
        # d[t2][0] = d.get(t2,[0,0,0,0,0])[0] + 1
        if sc1 > sc2:
            a1[1] += 1
            a1[4] += 3
            a2[3] += 1
        elif sc1 < sc2:
            a2[1] += 1
            a2[4] += 3
            a1[3] += 1
        else:
            a1[2] += 1
            a1[4] += 1
            a2[2] += 1
            a2[4] += 1
    #print(d)
    for i in d.keys():
        s = i+':'
        for j in range(5):
            s += str(d[i][j])+' '
        print(s)
    return


def command(c, res):
    if not c in dct: dct[c] = [0, 0, 0, 0, 0]
    dct[c] = [dct[c][0] + 1,
                dct[c][1] + 1 if res == 3 else dct[c][1],
                dct[c][2] + 1 if res == 1 else dct[c][2],
                dct[c][3] + 1 if res == 0 else dct[c][3],
                dct[c][4] + res,]
    return

def f3711():
    dct = {}
    for i in range(int(input())):
        c1, g1, c2, g2 = input().split(';')
        command(c1, 3 if g1 > g2 else 1 if g1 == g2 else 0)
        command(c2, 3 if g2 > g1 else 1 if g1 == g2 else 0)
    for c in dct:
        print('{}:{} {} {} {} {}'.format(c, *dct[c]))


def points_counter(team, goals1, goals2):
    if team not in d:
        d[team] = [0] * 5
    d[team][0] += 1
    d[team][1] += int(goals1 > goals2)
    d[team][2] += int(goals1 == goals2)
    d[team][3] += int(goals1 < goals2)
    d[team][4] += int(goals1 > goals2) * 3 + int(goals1 == goals2)
    return

def f3712():
    n, d = int(input()), {}
    for _ in range(n):
        k = input().split(';')
        points_counter(k[0], int(k[1]), int(k[3]))
        points_counter(k[2], int(k[3]), int(k[1]))
    for k, v in d.items():
        print(k + ":" + str(v[0]), v[1], v[2], v[3], v[4])


# ========================================== 3.7.2 ===========================================
'''В какой-то момент в Институте биоинформатики биологи перестали понимать, что говорят информатики: 
они говорили каким-то странным набором звуков.
В какой-то момент один из биологов раскрыл секрет информатиков: они использовали при общении подстановочный шифр, 
т.е. заменяли каждый символ исходного сообщения на соответствующий ему другой символ. Биологи раздобыли ключ к шифру 
и теперь нуждаются в помощи:
Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки 
одинаковой длины, на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, 
после чего идёт строка, которую нужно зашифровать переданным ключом, и ещё одна строка, которую нужно расшифровать.
Пусть, например, на вход программе передано:
abcd
*d%#
abacabadaba
#*%*d*%
Это значит, что символ a исходного сообщения заменяется на символ * в шифре, b заменяется на d, c — на % и d — на #.
Нужно зашифровать строку abacabadaba и расшифровать строку #*%*d*% с помощью этого шифра. Получаем следующие строки, 
которые и передаём на вывод программы:
*d*%*d*#*d*
dacabac'''

def f372():         # решение со словарями
    al1 = input()
    al2 = input()
    st1 = input()
    st2 = input()
    so1,so2 = '',''
    cipher = {al1[i]:al2[i] for i in range(len(al1))}
    # cipher2 = {al2[i]:al1[i] for i in range(len(al2))}
    cipher2 = dict(zip(al2,al1))
    # cipher2 = {v:k for k, v in cipher.items()}
    # print(cipher)
    # print(cipher2)
    for sign in st1:
        if sign in cipher:
            so1 += cipher[sign]
            # print(cipher[sign])
        else:
            so1 += sign
    for sign in st2:
        if sign in cipher2:
            so2 += cipher2[sign]
        else:
            so2 += sign
    print(so1+'\n'+so2)
    return


def f3721():        # решение без словарей
    al1 = input()
    al2 = input()
    st1 = input()
    st2 = input()
    so1,so2 = '',''
    for sign in st1:
        if sign in al1:
            so1 += al2[al1.find(sign)]
        else:
            so1 += sign
    for sign in st2:
        if sign in al2:
            so2 += al1[al2.find(sign)]
        else:
            so2 += sign
    print(so1+'\n'+so2)
    return


def f3722():        # Денис Хаит
    a,b,c,d=input(),input(),input(),input()
    print(''.join(b[a.index(i)] for i in c))
    print(''.join(a[b.index(i)] for i in d))
    return


def code(source, res, data):
    cryptData = ''
    for char in data:
        cryptData += res[source.index(char)]
    return cryptData

def f3723():
    key1 = input()
    key2 = input()
    decode = input()
    encode = input()
    print(code(key1, key2, decode))
    print(code(key2, key1, encode))
    return


def f3724():
    enc, dec = input(), input()
    d_enc = dict(zip(enc,dec))
    d_dec = dict(zip(dec,enc))
    print(''.join([d_enc[c] for c in input()]))
    print(''.join([d_dec[c] for c in input()]))
    return


# ========================================== 3.7.3 ===========================================
'''Простейшая система проверки орфографии может быть основана на использовании списка известных слов.
Если введённое слово не найдено в этом списке, оно помечается как "ошибка".
Попробуем написать подобную систему.
На вход программе первой строкой передаётся количество d известных нам слов, после чего на d строках указываются 
эти слова. Затем передаётся количество l строк текста для проверки, после чего l строк текста.
Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.'''

def f373():
    d = int(input())
    voc = {input().upper() for _ in range(d)}
    l = int(input())
    err = set()
    txt = [input() for _ in range(l)]
    for i in range(l):
        for w in txt[i].split():
            if w.upper() not in voc:
                if w.upper() not in err:
                    err.add(w.upper())
                    print(w)
    return


def f3731():
    # формируем множество известных слов на основании построчного ввода
    dic = {input().lower() for _ in range(int(input()))}
    # заводим пустое множество для приема текста
    wrd = set()
    # т.к. текст построчно подается, а также в каждой строке несколько слов,
    # то каждую строку превращаем во множество и добавляем в единое множество wrd
    for _ in range(int(input())):
        wrd |= {i.lower() for i in input().split()}
    # на вывод отправляем результат вычитания словарного множества dic
    # из текстового множества wrd; впереди ставим *, чтобы раскрыть поэлементно
    print(*(wrd-dic), sep="\n")


# ========================================== 3.7.4 ===========================================
'''Группа биологов в институте биоинформатики завела себе черепашку.
После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида:
север 10
запад 20
юг 30
восток 40
где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное 
расстояние в сантиметрах, которое должна пройти черепашка.
Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, 
которая определит, куда в итоге биологи приведут черепашку. Для этого программисты просят вас написать программу, 
которая выведет точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, что движение 
начинается в точке (0, 0), и движение на восток увеличивает первую координату, а на север — вторую.
Программе подаётся на вход число команд n, которые нужно выполнить черепашке, после чего n строк с самими командами. 
Вывести нужно два числа в одну строку: первую и вторую координату конечной точки черепашки. 
Все координаты целочисленные.'''

def f374():
    n = int(input())
    v = {'север':2, 'юг':-2, 'восток':1, 'запад':-1}
    p = [0,0]
    for i in range(n):
        d = input().split()
        # print(d)
        a = v[d[0]]
        r = int(d[1])
        # print(a)
        if a**2 > 1:
            p[1] += (a//2)*r
        else:
            p[0] += a*r
    print(*p,sep=' ')
    return


def f3741():
    dict = {'север': 0, 'юг': 0, 'запад': 0, 'восток': 0}
    for _ in range(int(input())):
        key, value = input().split()
        dict[key] += int(value)
    print(dict['восток'] - dict['запад'], dict['север'] - dict['юг'])
    return

# ========================================== 3.7.5 ===========================================
'''Дан файл с таблицей в формате TSV с информацией о росте школьников разных классов.
Напишите программу, которая прочитает этот файл и подсчитает для каждого класса средний рост учащегося.
Файл состоит из набора строк, каждая из которых представляет собой три поля:
Класс Фамилия Рост
Класс обозначается только числом. Буквенные модификаторы не используются. Номер класса может быть от 1 до 11 
включительно. В фамилии нет пробелов, а в качестве роста используется натуральное число, но при подсчёте среднего 
требуется вычислить значение в виде вещественного числа.
Выводить информацию о среднем росте следует в порядке возрастания номера класса (для классов с первого по 
одиннадцатый). Если про какой-то класс нет информации, необходимо вывести напротив него прочерк.
В качестве ответа прикрепите файл с полученными данными о среднем росте.'''

def f375():
    inf = input()
    l = [[0,0] for i in range(11)]
    # print(l)
    with open (inf,'r') as f:
        for s in f:
            s = s.strip().split()   # split('\t') ?
            # print(s)
            k = int(s[0])-1
            l[k][0] += int(s[2])
            l[k][1] += 1
    #print(l)
    for i in range(11):
        if l[i][0] == 0:
            print(i+1,' -')
        else:
            print(i+1,' ',l[i][0]/l[i][1])
    return

# =================================================================================================
#                            Main
# =================================================================================================

import requests
import sys
import math
import timeit       # оценка скорости вычислений
    # t1 = timeit.default_timer()
    # print(timeit.default_timer()-t1)

f375()





